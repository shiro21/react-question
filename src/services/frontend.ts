export const cs = [
    {
        id: 1,
        title: "객체지향 프로그램에 대해 설명해주세요.",
        arr: `
            객체지향프로그래밍( OOP: Object Oriented Programming )은 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고, 그 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.<br />
            장점으로는 코드 재사용 및 유지보수의 용이, 대형 프로젝트에 적합하는 점이고, 단점으로는 처리 속도가 느리고, 객체가 많으면 용량이 커진다는 것입니다.<br />
            OOP의 특징으로는 캡슐화, 상속, 추상화, 다형성이 있습니다.<br />
            <br />
            1. 캡슐화: 변수와 함수를 하나의 단위로 묶는 것, 정보 은닉<br />
            2. 상속: 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것<br />
            3. 추상화: 객체들의 공통적인 특징을 도출하는 것<br />
            4. 다형성: 하나의 변수 또는 함수가 상황에 따라 다른 의미로 해석될 수 있는 것
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 2,
        title: "HTTP와 HTTPS의 차이점에 대해 설명해 주세요.",
        arr: `
            HTTP는 서버/클라이언트 모델을 따라 데이터를 주고받기 위한 프로토콜입니다. HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜입니다.<br />
            공개키/개인키 암호화 방식을 이용해 데이터를 암호화합니다. HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있습니다.<br />
            하지만 HTTPS를 이용하면 암호화/복호화 과정이 필요해지기 때문에 HTTP보다 속도가 느려집니다. ( 실 사용에서는 차이가 거의 없습니다. )<br />
            HTTPS는 인증서를 발급하고 유지하는데 추가 비용이 발생합니다. 개인정보와 같은 민감한 데이터를 주고 받는다면 HTTPS를 이용해야 하지만, 단순 정보 조회 같은 사이트는 HTTP를 적용해도 됩니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/447",
        link2: ""
    },
    {
        id: 3,
        title: "객체지향프로그래밍에 대해 설명해 주세요.",
        arr: `
            객체지향프로그래밍( OOP: Object Oriented Programming )은 컴퓨터 프로그래밍 패러다임 중 하나로, 데이터를 춯상화시켜 상태( Attribute )와 행위( Method )를 가진 객체로 만들고 그 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.<br />
            <br />
            장점: 코드 재사용 및 유지보수 용이하고 대형 프로젝트에 적합합니다.<br />
            단점: 처리속도가 느리고 설계 시 많은 시간이 필요하며, 객체가 많을 경우 용량이 커집니다.<br />
            <br />
            객체지향의 특성<br />
            1. 추상화: 객체의 공통적인 속성과 기능을 추출하여 정의하는 것입니다.
            2. 상속: 클래스간에 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시켜 해당 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있도록 합니다.<br />
            3. 다형성: 어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할 수 있는 객체지향의 특성을 의미합니다.<br />
            4. 캡슐화: 외부로부터 클래스에 정의된 속성과 기능들을 보호하고, 필요한 부분만 외부로 노출될 수 있도록하여 각 객체 고유의 독립성과 책임 영영을 안전하게 지키고자 하는 목적이 있습니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/448",
        link2: ""
    },
]

export const javascript = [
    {
        id: 1,
        title: "호이스팅( Hoisting )에 대해 설명해 주세요.",
        arr: `
            Javascript에서는 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당해 줍니다.<br />
            이로 인해서 변수 및 함수 선언이 스코프의 최상단으로 끌어올려진 것 같은 현상이 발생하게 되는데, 이를 호이스팅이라고 합니다.<br />
            <br />
            <span style="color: red">주의</span>: 함수 선언식은 호이스팅 되지만, 함수 표현식은 호이스팅 되지 않습니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/429",
        link2: ""
    },
    {
        id: 2,
        title: "클로저는 무엇이며, 왜 사용하나요?",
        arr: `
            클로저는 함수와 해당 함수가 선언된 렉시컬 환경의 조합입니다. 외부 함수가 반환된 후에도 외부 함수의 변수 범위 체인에 접근할 수 있는 함수입니다.<br />
            전역 변수의 사용을 억제하고, 정보를 은닉하기 위해 사용합니다.<br />
            <br />
            - 현재 상태를 기억하고, 변경된 최신 상태를 유지<br />
            - 전역 변수 사용 억제<br />
            - 정보 은닉
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/429",
        link2: ""
    },
    {
        id: 3,
        title: "this에 대해서 설명해 주세요.",
        arr: `
            this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이며, 함수의 호출방식에 따라 특정 객체를 바인딩하게 됩니다.<br />
            <br />
            1. 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스와 바인딩됩니다.<br />
            2. call, apply, bind 메서드를 사용 시, 함수의 첫 번째 인수로 전달하는 객체에 바인딩됩니다.<br />
            3. Object.method 형태와 같이 객체 내에서 호출할 경우, this는 해당 객체와 바인딩됩니다.<br />
            4. 위 3가지를 제외한 일반 함수 호출의 경우 this는 전역 객체와 바인딩됩니다.<br />
            5. 화살표 함수 내에서 this가 사용될 경우, this는 상위 스코프의 this와 바인딩됩니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/431",
        link2: ""
    },
    {
        id: 4,
        title: "이벤트 버블링과 캡처링에 대해 설명해 주세요.",
        arr: `
            1. 이벤트 버블링 ( Event Bubbling )<br />
             - 특정 화면 요소에서 이벤트가 발생했을 때, 해당 이벤트가 상위의 화면 요소들로 전달되는 특성입니다.<br />
            <br />
            2. 이벤트 캡처링 ( Event Capturing )<br />
             - 이벤트 버블링과 반대로 상위요소에서 하위요소를 탐색하여 이벤트를 탐색하여 이벤트를 전파하는 방식입니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/436",
        link2: ""
    },
    {
        id: 5,
        title: "타입스크립를 쓰는 이유에 대해 설명해 주세요.",
        arr: `
            타입스크립트는 MS에서 개발하고 관리하는 오픈소스 프로그래밍 언어이며, 자바스크립트의 단점을 보완하기 위해 만들어진 언어입니다.<br />
            정적타입으로 컴파일 단계에서 오류를 포착할 수 있는 장점이 있고, 강력한 객체지향 프로그래밍을 지원합니다. ES6의 새로운 기능들을 사용하기 위해 바벨과 같은 별도 트랜스파일러를 사용하지 않아도 ES6의 새로운 기능을 기존의 자바스크립트 엔진에서 실행 가능합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/440",
        link2: ""
    },
    {
        id: 6,
        title: "var, let, const의 차이점을 설명해 주세요.",
        arr: `
            1. var<br />
             - 중복 선언 가능<br />
             - 함수레벨 스코프<br />
            2. let<br />
             - 중복 선언 불가능<br />
             - 재할당 가능<br />
             - 블록레벨 스코프<br />
            3. const<br />
             - 중복 선언 불가능<br />
             - 재할당 불가능<br />
             - 블록레벨 스코프<br />
            <br />
            let과 const는 블록 스코프를 갖고 공통적으로 재선언이 되지 않습니다. 그러나 let은 재할당이 가능하고, const는 선언과 동시에 할당이 되기 때문에 재할당이 불가능합니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 7,
        title: "비동기 함수에 대해 설명해 주세요.",
        arr: `
            비동기 함수는 현재 실행중인 코드 완료 여부와 무관하게 다음 코드로 넘어갑니다. 즉 요청과 응답이 동시에 이루어지지 않습니다.<br />
            비동기 방식이 필요한 이유는 화면에서 서버로 데이터를 요청했을 때, 요청에 대한 응답을 무한정 기다릴 수 없기 때문에 기다리는 시간동안 다른 작업을 할 수 있도록 도와줍니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/449",
        link2: ""
    },
    {
        id: 8,
        title: "Promise에 대해 설명해 주세요.",
        arr: `
            프로미스는 비동기 동작을 다루기 위한 패턴으로, 비동기 요청을 보내면 성공 또는 실패가 다양한 형태로 발생합니다. 프로미스를 사용하면 이러한 성공이나 실패를 편리한 방식으로 환원할 수 있습니다.<br />
            new 연산자와 함께 호출한 프로미스의 인자로 넘겨주는 콜백함수는 호출할 때 바로 실행하며, 그 내부에 resolve, reject함수를 호출하는 구문이 있으면 둘 중 하나가 실행되기 전까지는 다음 .then().catch()구문으로 넘어가지 않습니다.<br />
            pending, fulfilled, rejected 3가지 상태를 가집니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/450",
        link2: ""
    },
    {
        id: 9,
        title: "Async & Await과 Promise의 차이점을 설명해 주세요.",
        arr: `
            프로미스를 사용할 때는 .catch()문으로 에러 핸들링이 가능합니다. 반대로 async/await은 에러 핸들링 기능이 따로 없기 때문에 try...catch()문을 사용해야 합니다.<br />
            프로미스는 .then() 지옥의 가능성이 있기 때문에, 코드 길어질수록 async/await문을 사용하면 가독성에 유리합니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 10,
        title: "ESLint에 대해 설명해 주세요.",
        arr: `
            자바스크립트 언어와 소스 코드를 분석하는 도구로 ESLint패키지를 설치해주면 코드에 특정 스타일과 규칙을 적용해 에러를 찾고 패턴을 적용시킬 수 있는 분석 툴입니다.<br />
            사용 시 ECMAScript코드에서 문제점을 검사하고 일부는 더 나은 코드로 정정해주는 유용한 도구입니다.<br />
            코드의 가독성을 높이고 잠재적인 오류와 버그를 제거해 단단한 코드를 만드는 것이 목적입니다.<br />
            추가로 코드를 더 보기좋도록 포맷팅 해주는 Prettier를 ESLint와 함께 사용해주면 더 효율적입니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/451",
        link2: ""
    },
    {
        id: 11,
        title: "ES6 문법에 추가된 내용들을 말씀해 주세요.",
        arr: `
            String Literal, 객체 비구조화, Object Literal, for...of, Spread Operator, Rest Parameter, Arrow Function, Default Params, let & const, import & export, Map & Set
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
]

export const frontend = [
    {
        id: 1,
        title: "브라우저 렌더링 과정을 설명해 주세요.",
        arr: `
            1. Parsing: HTML파일과 CSS파일의 파싱해 각각 트리를 만들어줍니다.<br />
            2. Style: 두 트리를 결합해서 렌더링 트리( Rendering Tree )를 만들어줍니다.<br />
            3. Layout: 렌더링 트리에서 각 노드의 위치와 크기를 계산합니다.<br />
            4. Paint: 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만들어줍니다.<br />
            5. Composite: 레이어를 합성하여 실제 화면에 나타내줍니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/324",
        link2: "https://d2.naver.com/helloworld/59361"
    },
    {
        id: 2,
        title: "로컬 스토리지, 세션 스토리지, 쿠키에 대해서 설명해 주세요.",
        arr: `
            1. 로컬스토리지 ( localStorage )<br />
             - 로컬스토리지는 브라우저 내에서 로컬로 데이터를 저장할 수 있는 저장소입니다. 로컬스토리지에 저장된 데이터는 사용자가 브라우저를 새로고침 하거나 브라우저를 닫은 후에도 그대로 유지됩니다.<br />
            <br />
            2. 세션스토리지 ( sessionStorage )<br />
             - 세션트로지는 로컬스토리지와 비슷하지만 사용자가 브라우저를 닫으면 저장된 데이터가 사라집니다. 일회성 로그인, 비회원 장바구니와 같은 임시 데이터를 저장하는데 사용될 수 있습니다.<br />
            <br />
            3. 쿠키 ( Cookie )
             - 쿠키는 클라이언트 로컬에 저장되는 키와 값이 있는 매우 작은 텍스트 파일입니다. 4kb의 크기 제한이 있으며, 일정 시간이 지나면 만료되도록 설정할 수 있고 만료 후에는 브라우저에서 사라집니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/432",
        link2: ""
    },
    {
        id: 3,
        title: "CSR, SSR의 차이점을 설명해 주세요.",
        arr: `
            1.CSR ( Client Side Rendering )<br />
             - 클라이언트측에서 HTML을 반환한 후에, 자바스크립트가 동작하면서 데이터만을 주고받아 클라이언트에서 렌더링을 진행합니다.<br />
            <br />
            2. SSR ( Server Side Rendering )<br />
             - 사용자가 웹 페이지에 접근할 때, 서버 각 페이지에 대해 요청하고 서버에서 HTML, Javascript 파일등을 모두 다운로드하여 화면에 렌더링을 진행합니다.<br />
            <br />
            <br />
            초기로딩 측면에서 SSR은 CSR에 비해 다운받는 파일이 많지 않기 때문에 속도가 빠른 반면, CSR은 모든 자바스크립트파일을 받아와야 하기 때문에 초기에 오래 걸립니다.<br />
            서버 부담측면에서 SSR은 서버와 잦은 응답을 하기 때문에 서버에 부담이 되고 UX측면이 떨어지는 반면, CSR은 데이터 요청이 있을때만 서버에 요처아기 때문에 서버에 부담이 적습니다.<br />
            SEO 측면에서 SSR은 HTML에 대한 정보가 처음에 포함되어 있기 때문에( SEO에 사용되는 meta tag들이 미리 정의되어 있습니다. ) 데이터를 수집할 수 있어 SEO에 유리한 반면, CSR은 맨 처음 HTML 파일이 비어있기 때문에 데이터 수집에 어려움이 있습니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/441",
        link2: ""
    },
    {
        id: 4,
        title: "React, Angular, Vue의 차이점을 설명해 주세요.",
        arr: `
            먼저 React, Angular, Vue의 공통점은 SPA기반의 프론트엔드 프레임워크/라이브러리라는 점입니다. 리액트는 단방향 바인딩으로 부모 컴포넌트에서 Props가 자식 컴포넌트로 전달되고, 뷰나 앵귤러는 양방향 바인딩이 가능하다는 차이가 있습니다.<br />
            러닝커브는 뷰가 가장 낮으며, 리액트는 .jsx문법을 사용하며, 개발 생태계가 가장 잘 활성화 되어 있으며, 큰 규모의 어플리케이션 개발에 유리합니다.<br />
            앵귤러와 뷰는 프레임워크이며, 앵귤러는 타입스크립트를 사용함으로써 코드의 가독성과 안정성이 좋지만 러닝커브가 높습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 5,
        title: "MVC, MVVM 패턴에 대해 설명해 주세요.",
        arr: `
            1. MVC ( Model-View-Controller )<br />
            MVC 패턴은 Model( 데이터 ), View( 화면 ), Controller( 컨트롤러 )로 구성된 디자인 패턴입니다.<br />
             - Model: 모델은 프론트엔드 애플리케이션의 데이터 및 로직을 나타내며, 애플리케이션의 상태를 관리하고 모든 비즈니스 로직을 처리합니다.<br />
             - View: 뷰는 데이터를 렌더링 하고 사용자에게 표시 및 상호작용 할 수 있는 인터페이스를 만드는 역할을 합니다.<br />
             - Controller: 컨트롤러는 모델과 뷰 사이의 중재자 역할을 합니다. 사용자의 입력을 처리하고 그에 따라 모델과 뷰를 업데이트합니다.<br />
            <br />
            2. MVVM ( Model-View-ViewModel )<br />
            MVVM 패턴은 Model, View, ViewModel로 구성되어 있으며 React, Angular, Vue와 같은 라이브러리나 프레임워크에서 일반적으로 사용되는 디자인 패턴입니다.<br />
             - Model: 모델은 MVC패턴과 마찬가지로 애플리케이션의 데이터와 로직을 나타냅니다.<br />
             - View: 뷰는 MVC패턴과 같이 데이터를 렌더링하고 사용자에게 표시하는 역할을 합니다.<br />
             - ViewModel: 뷰모델은 모델과 뷰 사이의 중재자 역할을 하며, 모델의 데이터를 뷰에 표시하기 쉬운 형식으로 변환하는 역할을 합니다. 또한 데이터에 대한 모든 업데이트를 처리하고 이를 모델에 다시 전달합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/443",
        link2: ""
    },
    {
        id: 6,
        title: "브라우저 주소창에 www.google.com을 입력하면 발생하는 일을 설명해 주세요.",
        arr: `
            1. 사용자가 웹브라우저 검색창에 www.google.com을 입력합니다.<br />
            2. 웹브라우저는 캐싱된 DNS 기록들을 통해 해당 도메인 주소와 대응하는 IP주소를 확인합니다.<br />
            3. 웹브라우저가 HTTP를 사용하여 DNS에게 입력된 도메인 주소를 요청합니다.<br />
            4. DNS가 웹브라우저에게 찾는 사이트의 IP주소를 응답합니다.<br />
            5. 웹브라우저가 웹 서버에게 IP주소를 이용하여 HTML문서를 요청합니다.<br />
            6. 웹 애플리케이션 서버( WAS )와 데이터베이스에서 우선 웹페이지 작업을 처리합니다.<br />
            7. 작업처리 결과를 웹서버로 전송합니다.<br />
            8. 웹 서버는 웹브라우저에게 HTML문서 결과를 응답합니다.<br />
            9. 웹브라우저는 화면에 웹페이지 내용을 출력합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/285",
        link2: ""
    }
]

export const react = [
    {
        id: 1,
        title: "DOM과 Virtual DOM에 대해서 설명해 주세요.",
        arr: `
            DOM은 Document Object Model의 약자로, HTML, XML 문서의 인터페이스를 의미합니다.<br />
            HTML은 브라우저에서 실행될 수 있게끔 DOM Tree로 파싱되고, 이를 바탕으로 렌더링됩니다. 가상돔은 추상화된 DOM을 뜻합니다. 기존 DOM을 조작하고 렌더링하는 부분에서 오는 시간을 줄여줍니다. DOM과 유사한 객체를 메모리에 올려놓고 변경 사항이 생기면 가상돔을 바꾸고, 실제 돔에서는 변경 사항만 변경하여 더 반응성 빠른 웹을 구현할 수 있습니다.<br />
            리액트 또한 가상돔을 이용하여 구현되었습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
]