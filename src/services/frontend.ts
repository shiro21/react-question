export const cs = [
    {
        id: 1,
        title: "객체지향 프로그램에 대해 설명해주세요.",
        arr: `
            객체지향프로그래밍( OOP: Object Oriented Programming )은 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고, 그 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.<br />
            장점으로는 코드 재사용 및 유지보수의 용이, 대형 프로젝트에 적합하는 점이고, 단점으로는 처리 속도가 느리고, 객체가 많으면 용량이 커진다는 것입니다.<br />
            OOP의 특징으로는 캡슐화, 상속, 추상화, 다형성이 있습니다.<br />
            <br />
            1. 캡슐화: 변수와 함수를 하나의 단위로 묶는 것, 정보 은닉<br />
            2. 상속: 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것<br />
            3. 추상화: 객체들의 공통적인 특징을 도출하는 것<br />
            4. 다형성: 하나의 변수 또는 함수가 상황에 따라 다른 의미로 해석될 수 있는 것
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 2,
        title: "HTTP와 HTTPS의 차이점에 대해 설명해 주세요.",
        arr: `
            HTTP는 서버/클라이언트 모델을 따라 데이터를 주고받기 위한 프로토콜입니다. HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜입니다.<br />
            공개키/개인키 암호화 방식을 이용해 데이터를 암호화합니다. HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있습니다.<br />
            하지만 HTTPS를 이용하면 암호화/복호화 과정이 필요해지기 때문에 HTTP보다 속도가 느려집니다. ( 실 사용에서는 차이가 거의 없습니다. )<br />
            HTTPS는 인증서를 발급하고 유지하는데 추가 비용이 발생합니다. 개인정보와 같은 민감한 데이터를 주고 받는다면 HTTPS를 이용해야 하지만, 단순 정보 조회 같은 사이트는 HTTP를 적용해도 됩니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/447",
        link2: ""
    },
    // {
    //     id: 3,
    //     title: "객체지향프로그래밍에 대해 설명해 주세요.",
    //     arr: `
    //         객체지향프로그래밍( OOP: Object Oriented Programming )은 컴퓨터 프로그래밍 패러다임 중 하나로, 데이터를 춯상화시켜 상태( Attribute )와 행위( Method )를 가진 객체로 만들고 그 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.<br />
    //         <br />
    //         장점: 코드 재사용 및 유지보수 용이하고 대형 프로젝트에 적합합니다.<br />
    //         단점: 처리속도가 느리고 설계 시 많은 시간이 필요하며, 객체가 많을 경우 용량이 커집니다.<br />
    //         <br />
    //         객체지향의 특성<br />
    //         1. 추상화: 객체의 공통적인 속성과 기능을 추출하여 정의하는 것입니다.
    //         2. 상속: 클래스간에 공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 시켜 해당 상위 클래스로부터 확장된 여러 개의 하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있도록 합니다.<br />
    //         3. 다형성: 어떤 객체의 속성이나 기능이 그 맥락에 따라 다른 역할을 수행할 수 있는 객체지향의 특성을 의미합니다.<br />
    //         4. 캡슐화: 외부로부터 클래스에 정의된 속성과 기능들을 보호하고, 필요한 부분만 외부로 노출될 수 있도록하여 각 객체 고유의 독립성과 책임 영영을 안전하게 지키고자 하는 목적이 있습니다.
    //     `,
    //     isOpen: false,
    //     link: "https://shiro21.tistory.com/448",
    //     link2: ""
    // },
    // {
    //     id: 4,
    //     title: "",
    //     arr: `
            
    //     `,
    //     isOpen: false,
    //     link: "",
    //     link2: ""
    // },
]

export const javascript = [
    {
        id: 1,
        title: "호이스팅( Hoisting )에 대해 설명해 주세요.",
        arr: `
            Javascript에서는 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당해 줍니다.<br />
            이로 인해서 변수 및 함수 선언이 스코프의 최상단으로 끌어올려진 것 같은 현상이 발생하게 되는데, 이를 호이스팅이라고 합니다.<br />
            <br />
            <span style="color: red">주의</span>: 함수 선언식은 호이스팅 되지만, 함수 표현식은 호이스팅 되지 않습니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/429",
        link2: ""
    },
    {
        id: 2,
        title: "클로저는 무엇이며, 왜 사용하나요?",
        arr: `
            클로저는 함수와 해당 함수가 선언된 렉시컬 환경의 조합입니다. 외부 함수가 반환된 후에도 외부 함수의 변수 범위 체인에 접근할 수 있는 함수입니다.<br />
            전역 변수의 사용을 억제하고, 정보를 은닉하기 위해 사용합니다.<br />
            <br />
            - 현재 상태를 기억하고, 변경된 최신 상태를 유지<br />
            - 전역 변수 사용 억제<br />
            - 정보 은닉
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/429",
        link2: ""
    },
    {
        id: 3,
        title: "this에 대해서 설명해 주세요.",
        arr: `
            this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이며, 함수의 호출방식에 따라 특정 객체를 바인딩하게 됩니다.<br />
            <br />
            1. 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스와 바인딩됩니다.<br />
            2. call, apply, bind 메서드를 사용 시, 함수의 첫 번째 인수로 전달하는 객체에 바인딩됩니다.<br />
            3. Object.method 형태와 같이 객체 내에서 호출할 경우, this는 해당 객체와 바인딩됩니다.<br />
            4. 위 3가지를 제외한 일반 함수 호출의 경우 this는 전역 객체와 바인딩됩니다.<br />
            5. 화살표 함수 내에서 this가 사용될 경우, this는 상위 스코프의 this와 바인딩됩니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/431",
        link2: ""
    },
    {
        id: 4,
        title: "이벤트 버블링과 캡처링에 대해 설명해 주세요.",
        arr: `
            1. 이벤트 버블링 ( Event Bubbling )<br />
             - 특정 화면 요소에서 이벤트가 발생했을 때, 해당 이벤트가 상위의 화면 요소들로 전달되는 특성입니다.<br />
            <br />
            2. 이벤트 캡처링 ( Event Capturing )<br />
             - 이벤트 버블링과 반대로 상위요소에서 하위요소를 탐색하여 이벤트를 탐색하여 이벤트를 전파하는 방식입니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/436",
        link2: ""
    },
    {
        id: 5,
        title: "타입스크립를 쓰는 이유에 대해 설명해 주세요.",
        arr: `
            타입스크립트는 MS에서 개발하고 관리하는 오픈소스 프로그래밍 언어이며, 자바스크립트의 단점을 보완하기 위해 만들어진 언어입니다.<br />
            정적타입으로 컴파일 단계에서 오류를 포착할 수 있는 장점이 있고, 강력한 객체지향 프로그래밍을 지원합니다. ES6의 새로운 기능들을 사용하기 위해 바벨과 같은 별도 트랜스파일러를 사용하지 않아도 ES6의 새로운 기능을 기존의 자바스크립트 엔진에서 실행 가능합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/440",
        link2: ""
    },
    {
        id: 6,
        title: "var, let, const의 차이점을 설명해 주세요.",
        arr: `
            1. var<br />
             - 중복 선언 가능<br />
             - 함수레벨 스코프<br />
            2. let<br />
             - 중복 선언 불가능<br />
             - 재할당 가능<br />
             - 블록레벨 스코프<br />
            3. const<br />
             - 중복 선언 불가능<br />
             - 재할당 불가능<br />
             - 블록레벨 스코프<br />
            <br />
            let과 const는 블록 스코프를 갖고 공통적으로 재선언이 되지 않습니다. 그러나 let은 재할당이 가능하고, const는 선언과 동시에 할당이 되기 때문에 재할당이 불가능합니다.<br />
            <br />
            <span style="color: red">함수레벨 스코프 ?</span><br />
            function boo () {
                var a = 1;
            }<br />
            console.log(a); // error<br />
            <br />
            for (var i = 1; i < 5; i++) { console.log(i) }<br />
            console.log(i); // 1 2 3 4 5<br />
            위처럼 함수내부에서 선언한 var는 외부에서 사용할 수 없지만 for문에서 선언한 var는 외부에서 사용할 수 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 7,
        title: "비동기 함수에 대해 설명해 주세요.",
        arr: `
            비동기 함수는 현재 실행중인 코드 완료 여부와 무관하게 다음 코드로 넘어갑니다. 즉 요청과 응답이 동시에 이루어지지 않습니다.<br />
            비동기 방식이 필요한 이유는 화면에서 서버로 데이터를 요청했을 때, 요청에 대한 응답을 무한정 기다릴 수 없기 때문에 기다리는 시간동안 다른 작업을 할 수 있도록 도와줍니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/449",
        link2: ""
    },
    {
        id: 8,
        title: "Promise에 대해 설명해 주세요.",
        arr: `
            프로미스는 비동기 동작을 다루기 위한 패턴으로, 비동기 요청을 보내면 성공 또는 실패가 다양한 형태로 발생합니다. 프로미스를 사용하면 이러한 성공이나 실패를 편리한 방식으로 환원할 수 있습니다.<br />
            new 연산자와 함께 호출한 프로미스의 인자로 넘겨주는 콜백함수는 호출할 때 바로 실행하며, 그 내부에 resolve, reject함수를 호출하는 구문이 있으면 둘 중 하나가 실행되기 전까지는 다음 .then().catch()구문으로 넘어가지 않습니다.<br />
            pending, fulfilled, rejected 3가지 상태를 가집니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/450",
        link2: ""
    },
    {
        id: 9,
        title: "Async & Await과 Promise의 차이점을 설명해 주세요.",
        arr: `
            프로미스를 사용할 때는 .catch()문으로 에러 핸들링이 가능합니다. 반대로 async/await은 에러 핸들링 기능이 따로 없기 때문에 try/catch()문을 사용해야 합니다.<br />
            프로미스는 .then() 지옥의 가능성이 있기 때문에, 코드 길어질수록 async/await문을 사용하면 가독성에 유리합니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 10,
        title: "ESLint에 대해 설명해 주세요.",
        arr: `
            자바스크립트 언어와 소스 코드를 분석하는 도구로 ESLint패키지를 설치해주면 코드에 특정 스타일과 규칙을 적용해 에러를 찾고 패턴을 적용시킬 수 있는 분석 툴입니다.<br />
            사용 시 ECMAScript코드에서 문제점을 검사하고 일부는 더 나은 코드로 정정해주는 유용한 도구입니다.<br />
            코드의 가독성을 높이고 잠재적인 오류와 버그를 제거해 단단한 코드를 만드는 것이 목적입니다.<br />
            추가로 코드를 더 보기좋도록 포맷팅 해주는 Prettier를 ESLint와 함께 사용해주면 더 효율적입니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/451",
        link2: ""
    },
    {
        id: 11,
        title: "ES6 문법에 추가된 내용들을 말씀해 주세요.",
        arr: `
            String Literal, 객체 비구조화, Object Literal, for...of, Spread Operator, Rest Parameter, Arrow Function, Default Params, let & const, import & export, Map & Set
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 12,
        title: "async / await에 대해서 설명해 주세요.",
        arr: `
            async/await은 비동기식 코드를 동기식으로 표현하여 간단하게 나타내는 것을 의미합니다.<br />
            함수 선언자 앞에 async를 붙여주고, 비동기가 필요한 작업 앞에 await을 붙여서 결과를 기다립니다. 다수의 비동기 처리 작업을 할 때 유용하고 try/catch를 이용해서 에러 핸들링을 할 수 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 13,
        title: ".call과 .apply의 차이점에 대해서 설명해 주세요.",
        arr: `
            this가 함수 호출식에 따라 객체를 가리켰다면 call apply bind는 함수가 직접 실행문맥을 결정합니다.<br />
            그 중에서 call과 apply는 함수를 호출해서 실행합니다. 두번째로 쓰이는 매개변수가 배열일 경우 apply를 사용합니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 14,
        title: "AJAX에 대해서 설명해 주세요.",
        arr: `
            AJAX는 Asynchronous Javascript And XML의 약자로, 브라우저가 갖고 있는 XMLHttpRequest 객체를 이용해서 서버와 브라우저가 비동기 방식으로 데이터를 교환할 수 있는 통신 기능입니다.<br />
            장점으로는 SPA와 마찬가지로 웹페이지를 업데이트시 새로고침 없이 필요한 부분만 업데이트 되어서 UX가 향상됩니다. 반대로 단점은 SEO가 까다롭고, 동적화면에서 History 관리와 북마크가 어렵습니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/273",
        link2: ""
    },
    {
        id: 15,
        title: "use strict에 대해 설명해 주세요.",
        arr: `
            use strict는 ES5부터 지원했으며, 암묵적인 느슨한 모드( Sloppy Mode )를 해제하고, 명시적인 엄격 모드( Strict Mode )를 사용하는 방법입니다.<br />
            자바스크립트 언어의 문법을 보다 엄격하게 적용하여 기존에는 무시되던 오류를 발생시킬 가능성이 높거나 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킵니다. 전역에서 선언하면 모든 소스코드가 대상이고, 로컬로 선언하면 함수 내에서만 대상이 됩니다.<br />
            use strict 모드에서는 삭제가 불가능한 프로퍼티를 삭제하거나 함수의 매개변수를 중복해서 사용하는 것 등이 금지됩니다.<br />
            코드의 문제를 더 빨리 알게 되기 때문에 디버깅이 쉬워지고, 실수로 전역변수를 만드는 것이 불가능하지만, 단점으로는 엄격모드를 지원하지 않는 브라우저에서는 엄격 모드의 코드가 다른 방식으로 동작할 수 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 16,
        title: "Prototype과 Prototype Chaining에 대해서 설명해 주세요.",
        arr: `
            프로토타입이란 객체의 원형을 뜻합니다. 즉, 모든 객체는 프로토타입이라는 객체를 가지고 각각의 프로토타입으로부터 property와 method를 상속받습니다.<br />
            프로토타입 체인은 자바스크립트가 특정 객체의 property나 method에 접근하려고 할 때, 해당 프로퍼티나 메서드가 없을 시 Prototype이 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입 객체의 프로퍼티나 메서드를 차례대로 검색합니다. 이를 프로토타입 체인이라고 합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/454",
        link2: ""
    },
    {
        id: 17,
        title: "Event Binding에 대해서 설명해 주세요.",
        arr: `
            바인딩이란 서로 묶어서 연결해 준다는 뜻입니다. 이벤트 바인딩은 발생하는 이벤트와 그 후에 어떤 일이 벌어질지 알려주는 함수( 콜백함수 )와 묶어서 연결해 준다는 뜻입니다.<br />
            예를 들어, 어떤 버튼을 사용자가 클릭하게 되면, 클릭 이벤트가 발생하게 되고, 그 이벤트가 발생했을 때 어떤 일이 벌어진다는 것을 알려주는 콜백함수를 실행하게 됩니다. 이 때, 이 콜백 함수를 이벤트 핸들러라고 합니다.<br />
            <br />
            <br />
            이벤트 바인딩의 대표적인 3가지 방식<br />
            1. HTML 이벤트 핸들러<br />
            2. 전통적인 DOM 이벤트 핸들러<br />
            3. Event Listener를 이용한 이벤트 핸들러<br />
            <br />
            HTML 이벤트 핸들러는 HTML과 자바스크립트가 혼용되기 때문에 같이 사용하는 것을 피해야 합니다.<br />
            전통적인 DOM 이벤트 핸들러는 HTML 이벤트 핸들러의 문제는 해결했지만, 이벤트 핸들러에 하나의 함수만 바인딩 할 수 있고, 함수에 인수를 전달할 수 없으며, 바인딩된 이벤트 핸들러가 2개 이상일 경우 제일 마지막에 추가된 코드의 바인딩된 이벤트 핸들러만 실행된다는 단점이 있습니다.<br />
            마지막으로 이벤트 리스너를 이용한 이벤트 핸들러는 대상 요소( Event Target )에 이벤트를 바인딩하고, 해당 이벤트가 발생했을 때 실행될 콜백 함수를 지정해줍니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/455",
        link2: ""
    },
    {
        id: 18,
        title: "forEach와 map의 차이점에 대해 설명해 주세요.",
        arr: `
            두 메서드 모두 배열의 모든 원소를 돌면서 해당 요소에 관한 작업을 실행하는데, forEach는 원본을 변경시키고 map은 새로운 배열을 반환합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/455",
        link2: ""
    },
    {
        id: 19,
        title: "화살표 함수와 일반 함수의 차이점에 대해 설명해 주세요.",
        arr: `
            화살표 함수는 함수를 간단하게 표현할 수 있는 ES6문법입니다. 일반 함수는 this가 동적으로 바인딩되는 반면 화살표 함수는 바로 상위 스코프의 this와 같습니다. 또한, 화살표 함수는 프로토타입 프로퍼티를 갖고있지 않기 때문에 생성자 함수로 사용이 어렵고, 일반함수에서는 함수가 실행될 때 암묵적으로 arguments변수가 전달되어 사용할 수 있지만, 화살표 함수에서는 arguments변수가 전달되지 않습니다.<br />
            객체 프로토타입으로 메서드를 선언할 때에는 화살표 함수는 적합하지 않습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 20,
        title: "동등 연산자( == )와 일치 연산자( === )의 차이에 대해 설명해 주세요.",
        arr: `
            동등 연산자는 비교하는 대상의 타입이 다르더라도 강제로 비교를 해줍니다. 즉, 두 타입의 값이 다르더라도 형 변환된 값이 같다면 true를 리턴해줍니다.<br />
            일치 연산자는 동등 연산자보다 엄격하게 비교해줍니다. 타입과 값이 모두 같은 경우에만 true를 리턴해줍니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 21,
        title: "깊은복사와 얕은복사에 대해 설명해 주세요.",
        arr: `
            얕은 복사는 바로 아래 단계의 값만 복사하는 방법입니다. 즉, 객체를 복사할 때 원래값과 복사된 값이 같은 참조를 가리키고 있습니다.<br />
            깊은 복사는 내부의 모든 값들을 하나하나 찾아서 전부 복사하는 방법입니다. 즉, 객체안의 객체가 있을 경우에도 원본과의 참조가 완전히 끊어진 객체를 말합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/136",
        link2: ""
    },
    {
        id: 22,
        title: "NPM에 대해서 설명해 주세요.",
        arr: `
            npm은 Node Package Manager의 약자로, node.js로 만들어진 모듈을 웹에서 받아서 설치하고 관리해주는 프로그램입니다.<br />
            자바스크립트 패키지 매니저이며, node.js에서 사용할 수 있는 모듈들을 패키지화해서 모아둔 저장소 역할이며 설치 및 관리를 수행할 수 있는 CLI를 제공합니다.<br />
            많은 자바스크립트 프로그래머들이 유용한 패키지들을 만들어서 npm에 코드를 공개합니다.<br />
            이와 별개로 페이스북에서 만든 yarn 패키지 매니저가 있습니다. yarn은 npm 서버에 비해 속도가 빠르고 사용법이 npm과 비슷하기 때문에 쉽게 사용할 수 있습니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/136",
        link2: ""
    },
    {
        id: 23,
        title: "콜백함수에 대해서 설명해 주세요.",
        arr: `
            콜백함수는 다른함수의 인자로써 이용되는 함수이며 제어권도 함께 위임한 함수입니다. 위임받은 코드는 자체적인 내부 로직에 의해 콜백함수를 적절히 실행합니다. 비동기 처리시 콜백함수를 사용합니다.<br />
            콜백지옥에 빠지면 들여쓰기 수준이 높아지며 가독성이 떨어집니다. Promise나 Async/Await을 이용해서 보완합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/136",
        link2: ""
    },
    {
        id: 24,
        title: "스코프와 스코프 체인에 대해서 설명해 주세요.",
        arr: `
            스코프는 어떤 변수들에 접근할 수 있는 유효범위로 코드 어디서든 참조할 수 있는 전역스코프, 함수 자신과 하위 함수에서만 참조할 수 있는 지역스코프가 있습니다.<br />
            함수 안에서 선언된 변수는 해당 함수안에서만 사용할 수 있으니 전역변수에 영향을 끼칠 수 없습니다. 내부함수는 호출된 변수를 찾기위해 먼저 자신의 스코프에서 찾고 없으면 한단계씩 외부로 나가면서 찾습니다. 이렇게 꼬리를 물고 계속 범위를 넓히면서 찾는 관계를 스코프 체인이라고 합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/456",
        link2: ""
    },
    {
        id: 25,
        title: "import와 require의 차이점에 대해서 설명해 주세요.",
        arr: `
            import와 require는 모두 외부 라이브러리나 다른 파일을 불러오는 동일한 목적을 가지고 있습니다.<br />
            import의 경우 ES6에서 도입되었기 때문에 babel과 같은 ES6코드를 변환해주는 도구 없이는 사용하지 못합니다.<br />
            사용방법은 import는 그냥 바로 키워드를 사용하여 직관적으로 모듈을 불러 올 수 있고, require는 변수를 할당하듯이 불러와줍니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 26,
        title: "Map()과 Set()의 대해서 설명해 주세요.",
        arr: `
            Map은 key가 있는 데이터를 저장합니다. 객체와 비슷한 면이 있지만, 키에 대한 다양한 자료형을 허용합니다. 예를들어 객체의 키는 무조건 문자형이지만, Map에는 키의 자료형에 제한이 없습니다.<br />
            주의 사항은 객체처럼 Map[key]형태를 사용하면 일반 객체로 취급하기 때문에 쓰지 않는 것이 좋습니다.<br />
            Set은 중복을 허용하지 않는 값을 모아두는 객체입니다. new Set(iterable) 이런식으로 선언을 합니다. 요소의 유무를 판단할 때, Array.find보다 Set.has()가 더 효율적입니다.<br />
            <br />
            간단하게 보면 아래와 같습니다.<br />
            Map<br />
            key-value구조이며, key는 입력 순서를 유지하지 않으며, 중복을 허용하지 않고 value는 중복을 허용합니다. 그리고 인덱스가 따로 존재하지 않기 때문에 Iterator를 사용하여 조회합니다.<br />
            Set<br />
            입력 순서를 유지하지 않으며, 데이터의 중복을 허용하지 않습니다. 데이터에 null입력이 가능하나, 한 번만 저장하고 중복 저장을 허용하지 않습니다. 인덱스가 따로 존재하지 않기 때문에 Iterator를 사용하여 조회합니다.<br />
            추가: List<br />
            입력 순서를 유지하며, 데이터의 중복을 허용합니다. 인덱스를 통해 저장 데이터에 접근이 가능합니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 27,
        title: "전역변수와 지역변수",
        arr: `
            전역변수: 블록 밖에서 선언을 한 어디서든 쓰일 수 있는 변수<br />
            지역변수: 블록 안에서만 사용할 수 있는 변수<br />
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
]

export const frontend = [
    {
        id: 1,
        title: "브라우저 렌더링 과정을 설명해 주세요.",
        arr: `
            1. Parsing: HTML파일과 CSS파일의 파싱해 각각 트리를 만들어줍니다.<br />
            2. Style: 두 트리를 결합해서 렌더링 트리( Rendering Tree )를 만들어줍니다.<br />
            3. Layout: 렌더링 트리에서 각 노드의 위치와 크기를 계산합니다.<br />
            4. Paint: 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만들어줍니다.<br />
            5. Composite: 레이어를 합성하여 실제 화면에 나타내줍니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/324",
        link2: "https://d2.naver.com/helloworld/59361"
    },
    {
        id: 2,
        title: "로컬 스토리지, 세션 스토리지, 쿠키에 대해서 설명해 주세요.",
        arr: `
            1. 로컬스토리지 ( localStorage )<br />
             - 로컬스토리지는 브라우저 내에서 로컬로 데이터를 저장할 수 있는 저장소입니다. 로컬스토리지에 저장된 데이터는 사용자가 브라우저를 새로고침 하거나 브라우저를 닫은 후에도 그대로 유지됩니다.<br />
            <br />
            2. 세션스토리지 ( sessionStorage )<br />
             - 세션트로지는 로컬스토리지와 비슷하지만 사용자가 브라우저를 닫으면 저장된 데이터가 사라집니다. 일회성 로그인, 비회원 장바구니와 같은 임시 데이터를 저장하는데 사용될 수 있습니다.<br />
            <br />
            3. 쿠키 ( Cookie )
             - 쿠키는 클라이언트 로컬에 저장되는 키와 값이 있는 매우 작은 텍스트 파일입니다. 4kb의 크기 제한이 있으며, 일정 시간이 지나면 만료되도록 설정할 수 있고 만료 후에는 브라우저에서 사라집니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/432",
        link2: ""
    },
    {
        id: 3,
        title: "CSR, SSR의 차이점을 설명해 주세요.",
        arr: `
            1.CSR ( Client Side Rendering )<br />
             - 클라이언트측에서 HTML을 반환한 후에, 자바스크립트가 동작하면서 데이터만을 주고받아 클라이언트에서 렌더링을 진행합니다.<br />
            <br />
            2. SSR ( Server Side Rendering )<br />
             - 사용자가 웹 페이지에 접근할 때, 서버 각 페이지에 대해 요청하고 서버에서 HTML, Javascript 파일등을 모두 다운로드하여 화면에 렌더링을 진행합니다.<br />
            <br />
            <br />
            초기로딩 측면에서 SSR은 CSR에 비해 다운받는 파일이 많지 않기 때문에 속도가 빠른 반면, CSR은 모든 자바스크립트파일을 받아와야 하기 때문에 초기에 오래 걸립니다.<br />
            서버 부담측면에서 SSR은 서버와 잦은 응답을 하기 때문에 서버에 부담이 되고 UX측면이 떨어지는 반면, CSR은 데이터 요청이 있을때만 서버에 요청하기 때문에 서버에 부담이 적습니다.<br />
            SEO 측면에서 SSR은 HTML에 대한 정보가 처음에 포함되어 있기 때문에( SEO에 사용되는 meta tag들이 미리 정의되어 있습니다. ) 데이터를 수집할 수 있어 SEO에 유리한 반면, CSR은 맨 처음 HTML 파일이 비어있기 때문에 데이터 수집에 어려움이 있습니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/441",
        link2: ""
    },
    {
        id: 4,
        title: "React, Angular, Vue의 차이점을 설명해 주세요.",
        arr: `
            먼저 React, Angular, Vue의 공통점은 SPA기반의 프론트엔드 프레임워크/라이브러리라는 점입니다. 리액트는 단방향 바인딩으로 부모 컴포넌트에서 Props가 자식 컴포넌트로 전달되고, 뷰나 앵귤러는 양방향 바인딩이 가능하다는 차이가 있습니다.<br />
            러닝커브는 뷰가 가장 낮으며, 리액트는 .jsx문법을 사용하며, 개발 생태계가 가장 잘 활성화 되어 있으며, 큰 규모의 어플리케이션 개발에 유리합니다.<br />
            앵귤러와 뷰는 프레임워크이며, 앵귤러는 타입스크립트를 사용함으로써 코드의 가독성과 안정성이 좋지만 러닝커브가 높습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 5,
        title: "MVC, MVVM 패턴에 대해 설명해 주세요.",
        arr: `
            1. MVC ( Model-View-Controller )<br />
            MVC 패턴은 Model( 데이터 ), View( 화면 ), Controller( 컨트롤러 )로 구성된 디자인 패턴입니다.<br />
             - Model: 모델은 프론트엔드 애플리케이션의 데이터 및 로직을 나타내며, 애플리케이션의 상태를 관리하고 모든 비즈니스 로직을 처리합니다.<br />
             - View: 뷰는 데이터를 렌더링 하고 사용자에게 표시 및 상호작용 할 수 있는 인터페이스를 만드는 역할을 합니다.<br />
             - Controller: 컨트롤러는 모델과 뷰 사이의 중재자 역할을 합니다. 사용자의 입력을 처리하고 그에 따라 모델과 뷰를 업데이트합니다.<br />
            <br />
            2. MVVM ( Model-View-ViewModel )<br />
            MVVM 패턴은 Model, View, ViewModel로 구성되어 있으며 React, Angular, Vue와 같은 라이브러리나 프레임워크에서 일반적으로 사용되는 디자인 패턴입니다.<br />
             - Model: 모델은 MVC패턴과 마찬가지로 애플리케이션의 데이터와 로직을 나타냅니다.<br />
             - View: 뷰는 MVC패턴과 같이 데이터를 렌더링하고 사용자에게 표시하는 역할을 합니다.<br />
             - ViewModel: 뷰모델은 모델과 뷰 사이의 중재자 역할을 하며, 모델의 데이터를 뷰에 표시하기 쉬운 형식으로 변환하는 역할을 합니다. 또한 데이터에 대한 모든 업데이트를 처리하고 이를 모델에 다시 전달합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/443",
        link2: ""
    },
    {
        id: 6,
        title: "브라우저 주소창에 www.google.com을 입력하면 발생하는 일을 설명해 주세요.",
        arr: `
            1. 사용자가 웹브라우저 검색창에 www.google.com을 입력합니다.<br />
            2. 웹브라우저는 캐싱된 DNS 기록들을 통해 해당 도메인 주소와 대응하는 IP주소를 확인합니다.<br />
            3. 웹브라우저가 HTTP를 사용하여 DNS에게 입력된 도메인 주소를 요청합니다.<br />
            4. DNS가 웹브라우저에게 찾는 사이트의 IP주소를 응답합니다.<br />
            5. 웹브라우저가 웹 서버에게 IP주소를 이용하여 HTML문서를 요청합니다.<br />
            6. 웹 애플리케이션 서버( WAS )와 데이터베이스에서 우선 웹페이지 작업을 처리합니다.<br />
            7. 작업처리 결과를 웹서버로 전송합니다.<br />
            8. 웹 서버는 웹브라우저에게 HTML문서 결과를 응답합니다.<br />
            9. 웹브라우저는 화면에 웹페이지 내용을 출력합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/285",
        link2: ""
    },
    {
        id: 7,
        title: "Webpack, Babel, Polyfill에 대해서 설명해 주세요.",
        arr: `
            웹팩은 프로젝트의 구조를 분석하고 자바스크립트 모듈을 비롯한 관련 리소스들을 찾은 다음 이를 브라우저에서 사용할 수 있는 번들로 묶고 패킹하는 모듈 번들러입니다.<br />
            바벨은 모든 실행환경에서 자바스크립트가 정상적으로 동작할 수 있도록 ES6코드를 ES5코드로 변환해주고, JSX, TS까지 변환해주는 자바스크립트 컴파일러입니다.<br />
            폴리필은 브라우저가 지원하지 않는 자바스크립트 코드를 지원 가능하도록 변환한 코드 조각입니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/453",
        link2: ""
    },
    {
        id: 8,
        title: "JWT ( JSON Web Token )에 대해 설명해 주세요.",
        arr: `
            JWT는 JSON Web Token의 약자로, 데이터가 JSON으로 이루어져 있는 토큰을 말합니다. 기존의 세션인증방식은 인증 관련 정보를 세션 저장소라는 DB에 저장했기 때문에 서버가 과부화 되거나 서버를 확장하기 어려웠습니다. 이를 보완하기 위해 사용자 인증에 필요한 정보를 토큰 자체에 담고 있어 별도 저장소에 정보를 저장해 둘 필요가 없는 JWT를 사용하게 되었습니다.<br />
            토큰은 로그인 이후 서버가 만들어주는 문자열이고, 문자열 안에는 사용자의 로그인 정보와 서버의 서명이 들어있습니다. 사용자가 로그인을 하면 서버는 사용자에게 토큰을 발급하고, 사용자는 토큰과 함께 다른 API작업을 요청합니다. 서버는 토큰의 유효성 검사를 통해 요청한 것에 대한 응답을 해줍니다. 단, 한번 발급된 토큰은 수정 및 폐기가 불가하다는 단점이 있고, 유효기간을 짧게 지정해주는 것이 중요합니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 9,
        title: "CORS란 무엇이며, 해결하기 위한 방법에 대해 설명해 주세요.",
        arr: `
            CORS( Cross Origin Resource Sharing )란 교차 출처 리소스 공유란 뜻이며, 웹 페이지가 제공하는 도메인이 아닌 다른 도메인에서 리소스를 요청하는 것을 의미합니다.<br />
            브라우저는 CORS 에러를 발생시켜 악의적인 스크립트가 중요한 데이터에 접근하거나 무단 요청하지 못하도록 방지합니다.<br />
            <br />
            해결 방법으로는 프록시 서버를 설정해 주거나, 서버에서 CORS 헤더를 추가하여 특정 도메인의 요청을 허용하거나 크롬 확장 프로그램에서 Allow CORS를 사용하는 방법 등이 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 10,
        title: "REST API에 대해 설명해 주세요.",
        arr: `
            REST API( Representational State Transfer API )란 REST하게 클라이언트와 서버간의 데이터를 주고받는 방식입니다.<br />
            여기서 REST란 HTTP URI를 통해서 자원( Resource )을 명시하고, HTTP Method( GET, POST, PUT, DELETE )를 통해 해당 자원( URI )에 대한 CRUD Operation을 적용하는 것을 의미합니다. <br />
            이러한 REST 원리를 따르는 API를 RESTful API라고 합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/222",
        link2: ""
    },
    {
        id: 11,
        title: "Event Loop에 대해 설명해 주세요.",
        arr: `
            싱글 스레드 기반의 언어인 자바스크립트는 이벤트 루프를 이용해서 비동기 방식으로 동시성을 지원합니다.<br />
            이벤트 루프는 콜스택과 콜백큐의 상태를 체크하여 콜 스택이 빈 상태가 되면 콜백큐의 첫번째 콜백을 콜스택으로 밀어주는 역할을 합니다.<br />
            즉, 자바스크리트 엔진이 코드 조각을 하나씩 처리할 수 있도록 작업을 스케쥴하는 동시에 자바스크립트에서 비동기 작업을 처리할 수 있게 해줍니다.<br />
            모든 비동기 방식의 API들( setTimeOut, Ajax 등 )은 이벤트 루프를 통해 콜백 함수를 실행한다고 볼 수 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 12,
        title: "라이브러리와 프레임워크에 대해서 간단하게 설명해 주세요.",
        arr: `
            라이브러리는 응용프로그램 개발을 위해 필요한 기능을 모아놓은 소프트웨이고, 기능 사용법은 사용자가 결정합니다. 리액트가 UI를 만들기 위한 대표적인 자바스크립트의 라이브러리입니다.<br />
            프레임워크는 소프트웨어 개발을 위한 개발 환경, 토대, 기반시설을 제공하는 것이고 프로그래머는 프레임워크가 제공하는 전체적인 규칙을 따라가면서 개발해야합니다.<br />
            코드를 프레임워크가 제어하는 것이 라이브러리와의 차이점입니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 13,
        title: "크로스 브라우징에 대해서 설명해 주세요.",
        arr: `
            크로스 브라우징이란 어떤 환경에서 접근해도 동등하게 작동하는 것을 말합니다. 웹 표준 기술을 채용하여 다른 기종/플랫폼에 따라 달리 구현되는 기술을 비슷하게 만듦과 동시에 어느 한쪽에 최적화되어 치우치지 않도록 공통요소를 사용하여 웹 페이지를 제작하는 기법입니다.<br />
            쉽게 말해, 익스플로러에서 이용할 수 있던 사이트가 크롬이나 오페라에서는 보이지 않아 이용할 수 없는 것을 크로스 브라우징을 이용해서 사이트를 100% 이용할 수 있게 만드는 기술입니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 14,
        title: "HTTP요청 메서드 POST와 GET의 차이점에 대해 설명해 주세요.",
        arr: `
            GET은 주로 데이터를 읽거나 검색할때 사용되는 메서드인 반면 POST인 UPDATE나 CREATE할 때 사용됩니다. 예를들어 검색페이지는 GET요청을하고, 비밀번호 수정할때는 POST요청을 합니다.<br />
            GET은 데이터의 변형 위험이 없기 때문에 POST보다 안전하다고 간주됩니다. POST요청은 클라이언트에서 서버로 전송할 때 추가적인 데이터를 body에 포함할 수 있지만 GET요청은 필요한 데이터를 URL에 포함하여 요청합니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
]

export const react = [
    {
        id: 1,
        title: "DOM과 Virtual DOM에 대해서 설명해 주세요.",
        arr: `
            DOM은 Document Object Model의 약자로, HTML, XML 문서의 인터페이스를 의미합니다.<br />
            HTML은 브라우저에서 실행될 수 있게끔 DOM Tree로 파싱되고, 이를 바탕으로 렌더링됩니다. 가상돔은 추상화된 DOM을 뜻합니다. 기존 DOM을 조작하고 렌더링하는 부분에서 오는 시간을 줄여줍니다. DOM과 유사한 객체를 메모리에 올려놓고 변경 사항이 생기면 가상돔을 바꾸고, 실제 돔에서는 변경 사항만 변경하여 더 반응성 빠른 웹을 구현할 수 있습니다.<br />
            리액트 또한 가상돔을 이용하여 구현되었습니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/452",
        link2: ""
    },
    {
        id: 2,
        title: "React와 jQuery의 차이점에 대해서 설명해 주세요.",
        arr: `
            제이쿼리와 리액트 모두 웹사이트에 자바스크립트를 쉽게 활용할 수 있도록 도와주는 오픈소스 기반의 자바스크립트 라이브러리입니다. 제이쿼리는 인터넷 익스플로러의 시장 점유율이 높을땐 많이 사용되었지만, 크롬이 나타나면서 제이쿼리와 같은 라이브러리를 사용하지 않고도 양질의 웹 앱 구현이 가능해졌습니다.<br />
            리액트는 가상돔을 사용하는 라이브러리인데, 이와 같은 가상 돔을 사용하는 라이브러리가 많아질수록 돔을 직접 조작하는 제이쿼리의 필요성이 줄어들게 되었습니다. 가상돔을 사용하는 리액트는 제이쿼리보다 리렌더링 과정이 빠르고, 그렇다보니 더욱 많은 돔조작이 발생하는 규모가 큰 앱일수록 제이쿼리의 선호도가 떨어지고 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 3,
        title: "JSX가 무엇인가요?",
        arr: `
            JSX는 자바스크립트 코드를 HTML처럼 표현할 수 있는 리액트 엘리먼트를 생성하는 언어입니다.<br />
            간단하게 말하면 HTML과 자바스크립트를 모두 포함하고 있는 컴포넌트를 생성합니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 4,
        title: "useCallback의 동작원리에 대해 설명해 주세요.",
        arr: `
            useCallback은 변수가 선언되면 해당 함수가 실행됩니다. 그 후에 deps의 변경을 통해 값이 변경되면 새로운 함수를 리턴하고, 값이 변경되지 않는다면 기존 함수를 리턴합니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 5,
        title: "React란 무엇인가요?",
        arr: `
            리액트는 2011년 페이스북의 개발자들에 의해 탄생한 자바스크립트 라이브러리로서, 웹/모바일 애플리케이션의 뷰를 개발할 때 사용됩니다. 리액트는 컴포넌트에 기반한 접근 방식을 사용하므로, 재사용 가능성이 높은 컴포넌트를 개발할 수 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 6,
        title: "React의 주요 특징은 무엇인가요?",
        arr: `
            리액트는 단방향 데이터 흐름 모델을 사용하고, 가상 DOM을 사용합니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 7,
        title: "브라우저가 JSX파일을 읽을 수 있나요?",
        arr: `
            브라우저는 JSX파일을 직접 읽을 수 없습니다. 브라우저가 JSX파일을 읽으려면 JSX를 자바스크립트 객체로 변환을 해야합니다. 그리고 그 변환 작업은 바벨과 같은 컴파일러를 통해 이루어집니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 8,
        title: "React의 단점은 무엇인가요?",
        arr: `
            리액트는 단순 라이브러리이기 때문에, 더 많은 기능을 사용하고자 한다면 Redux, Router등 의존성 모듈이 필요합니다.<br />
            그리고 단방향 데이터 바인딩과만 제공하는 것이 복잡도를 줄이기 때문에 장점이기도 하지만, 양방향 바인딩에 비해 더 많은 양의 코드를 작성해야 하므로 불편할 수도 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 9,
        title: "React에서 렌더링이 어떻게 동작하나요?",
        arr: `
            리액트에서 모든 컴포넌트가 렌더링이 되어야 하기 때문에 렌더링이 매우 중요한 부분입니다. 리액트에서 렌더링은 render()함수를 통해 이루어지는데, 이 함수가 호출되면 DOM요소를 나타내는 요소가 반환됩니다.<br />
            한번에 둘 이상의 HTML요소를 렌더링하는 것도 가능합니다. HTML요소들을 여는 태그, 닫는 태그로 감싸면 여러 요소를 동시에 렌더링할 수 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 10,
        title: "React에서 상태( state )는 무엇인가요?",
        arr: `
            리액트에서 상태는 컴포넌트의 동작 및 렌더링과 같은 부분을 제어하는 데이터 또는 객체를 의미합니다.<br />
            상태를 이용해서 동적이고 인터랙티브한 컴포넌트를 쉽게 개발할 수 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 11,
        title: "React에서 props란 무엇인가요?",
        arr: `
            리액트에서 프롭스는 프로퍼티( properties, 속성 )의 줄임말로, 읽기만 가능하며 불변성을 지닌 요소를 의미합니다.<br />
            애플리케이션에서 프롭스는 부모 컴포넌트로부터 자식 컴포넌트로 전달되는 계층 구조를 따릅니다. 반대는 불가능합니다. 리액트는 단방향 데이터 흐름 모델을 사용하기 때문입니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 12,
        title: "CRA란 무엇인가요?",
        arr: `
            CRA는 create-react-app의 약자로, 리액트의 공식 CLI( 명령줄 인터페이스 )로써, SPA개발 초기 세팅을 편리하게 할 수 있도록 도와줍니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 13,
        title: "React에서 key는 어떻게 사용되나요?",
        arr: `
            리액트에서 collection을 렌더링할 때 요소와 데이터 사이의 관계를 추적하기 쉽도록 반복되는 요소에 key를 추가해 주는 것이 중요합니다. 키는 고유한 ID를 사용해야 하지만, 마지막 수단으로 Array index를 사용할 수 있습니다. key를 사용하지 않으면 collection에 아이템을 추가하거나 할 때 예상하지 못한 동작 결과가 발생할 수 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 14,
        title: "React에서 state는 왜 setState를 이용하나요?",
        arr: `
            만약에 컴포넌트의 state를 직접 변경하려고 시도한다면 리액트는 컴포넌트를 다시 렌더링해야 하는지 알 수 있는 방법이 없습니다. setState()메서드를 사용하면 리액트는 컴포넌트의 UI를 업데이트할 수 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 15,
        title: "React Context는 무엇인가요?",
        arr: `
            리액트는 하나의 애플리케이션 안에서 다수의 컴포넌트들이 상태를 공유할 때 발생하는 문제들에 대해 대응하기 위한 Context API를 제공합니다. Context가 도입되기 전에는 Redux와 같은 별도의 상태 관리 라이브러리를 추가하는 것이 유일한 방법이었습니다. 소규모의 앱에서는 Redux가 불필요한 복잡성을 유발하기 떄문에 이럴때 이용할 수 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 16,
        title: "Redux는 무엇인가요?",
        arr: `
            Redux는 리액트를 위한 Third-Party 상태관리 라이브러리로 Context API가 개발되기 이전부터 존재했습니다. 리덕스에는 Store라고 불리는 상태 컨테이너의 개념을 기반으로 하는데, 스토어 컴포넌트는 데이터를 프롭스로 받을 수 있습니다. 스토어를 업데이트 하려면 reducer를 통해 전달되는 스토어에 Action을 보내는 것입니다. 리듀서는 액션의 현재의 상태를 받고, 새로운 상태를 리턴하고 구독된 컴포넌트를 다시 렌더링하게 합니다.<br />
            Store - ( subscribe ) -> Component - ( trigger ) -> Action - ( dispatch ) -> Reducer - ( new state ) -> Store
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 17,
        title: "React hooks는 무엇이고 장점은 무엇인가요?",
        arr: `
            hooks는 클래스 기반 컴포넌트의 장점을 함수형 컴포넌트로 가져오려는 리액트의 시도입니다.<br />
            이점들은 첫번째로 클래스 기반 컴포넌트, 라이프사이클 훅, this의 필요성이 사라집니다.<br />
            두번째로 공통 기능을 커스텀 훅으로 만들어 로직을 재사용하기 쉬워집니다.<br />
            세번째로 컴포넌트 자체에서 로직을 분리할 수 있기 때문에 읽기 쉽고 테스트하기 쉬운 코드를 작성할 수 있습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
]