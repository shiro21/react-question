export const cs = [
    {
        id: 1,
        title: "객체지향 프로그램에 대해 설명해주세요.",
        arr: `
            객체지향프로그래밍( OOP: Object Oriented Programming )은 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고, 그 객체들간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법입니다.<br />
            장점으로는 코드 재사용 및 유지보수의 용이, 대형 프로젝트에 적합하는 점이고, 단점으로는 처리 속도가 느리고, 객체가 많으면 용량이 커진다는 것입니다.<br />
            OOP의 특징으로는 캡슐화, 상속, 추상화, 다형성이 있습니다.<br />
            <br />
            1. 캡슐화: 변수와 함수를 하나의 단위로 묶는 것, 정보 은닉<br />
            2. 상속: 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것<br />
            3. 추상화: 객체들의 공통적인 특징을 도출하는 것<br />
            4. 다형성: 하나의 변수 또는 함수가 상황에 따라 다른 의미로 해석될 수 있는 것
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 2,
        title: "HTTP와 HTTPS의 차이점에 대해 설명해 주세요.",
        arr: `
            HTTP는 서버/클라이언트 모델을 따라 데이터를 주고받기 위한 프로토콜입니다. HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜입니다.<br />
            공개키/개인키 암호화 방식을 이용해 데이터를 암호화합니다. HTTP는 암호화가 추가되지 않았기 때문에 보안에 취약한 반면, HTTPS는 안전하게 데이터를 주고받을 수 있습니다.<br />
            하지만 HTTPS를 이용하면 암호화/복호화 과정이 필요해지기 때문에 HTTP보다 속도가 느려집니다. ( 실 사용에서는 차이가 거의 없습니다. )<br />
            HTTPS는 인증서를 발급하고 유지하는데 추가 비용이 발생합니다. 개인정보와 같은 민감한 데이터를 주고 받는다면 HTTPS를 이용해야 하지만, 단순 정보 조회 같은 사이트는 HTTP를 적용해도 됩니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
]

export const javascript = [
    {
        id: 1,
        title: "호이스팅( Hoisting )에 대해 설명해 주세요.",
        arr: `
            Javascript에서는 인터프리터가 변수와 함수의 메모리 공간을 선언 전에 미리 할당해 줍니다.<br />
            이로 인해서 변수 및 함수 선언이 스코프의 최상단으로 끌어올려진 것 같은 현상이 발생하게 되는데, 이를 호이스팅이라고 합니다.<br />
            <br />
            <span style="color: red">주의</span>: 함수 선언식은 호이스팅 되지만, 함수 표현식은 호이스팅 되지 않습니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/429",
        link2: ""
    },
    {
        id: 2,
        title: "클로저는 무엇이며, 왜 사용하나요?",
        arr: `
            클로저는 함수와 해당 함수가 선언된 렉시컬 환경의 조합입니다. 외부 함수가 반환된 후에도 외부 함수의 변수 범위 체인에 접근할 수 있는 함수입니다.<br />
            전역 변수의 사용을 억제하고, 정보를 은닉하기 위해 사용합니다.<br />
            <br />
            - 현재 상태를 기억하고, 변경된 최신 상태를 유지<br />
            - 전역 변수 사용 억제<br />
            - 정보 은닉
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/429",
        link2: ""
    },
    {
        id: 3,
        title: "this에 대해서 설명해 주세요.",
        arr: `
            this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수이며, 함수의 호출방식에 따라 특정 객체를 바인딩하게 됩니다.<br />
            <br />
            1. 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스와 바인딩됩니다.<br />
            2. call, apply, bind 메서드를 사용 시, 함수의 첫 번째 인수로 전달하는 객체에 바인딩됩니다.<br />
            3. Object.method 형태와 같이 객체 내에서 호출할 경우, this는 해당 객체와 바인딩됩니다.<br />
            4. 위 3가지를 제외한 일반 함수 호출의 경우 this는 전역 객체와 바인딩됩니다.<br />
            5. 화살표 함수 내에서 this가 사용될 경우, this는 상위 스코프의 this와 바인딩됩니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/431",
        link2: ""
    },
    {
        id: 4,
        title: "이벤트 버블링과 캡처링에 대해 설명해 주세요.",
        arr: `
            1. 이벤트 버블링 ( Event Bubbling )<br />
             - 특정 화면 요소에서 이벤트가 발생했을 때, 해당 이벤트가 상위의 화면 요소들로 전달되는 특성입니다.<br />
            <br />
            2. 이벤트 캡처링 ( Event Capturing )<br />
             - 이벤트 버블링과 반대로 상위요소에서 하위요소를 탐색하여 이벤트를 탐색하여 이벤트를 전파하는 방식입니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/436",
        link2: ""
    },
    {
        id: 5,
        title: "타입스크립를 쓰는 이유에 대해 설명해 주세요.",
        arr: `
            타입스크립트는 MS에서 개발하고 관리하는 오픈소스 프로그래밍 언어이며, 자바스크립트의 단점을 보완하기 위해 만들어진 언어입니다.<br />
            정적타입으로 컴파일 단계에서 오류를 포착할 수 있는 장점이 있고, 강력한 객체지향 프로그래밍을 지원합니다. ES6의 새로운 기능들을 사용하기 위해 바벨과 같은 별도 트랜스파일러를 사용하지 않아도 ES6의 새로운 기능을 기존의 자바스크립트 엔진에서 실행 가능합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/440",
        link2: ""
    },
    {
        id: 6,
        title: "var, let, const의 차이점을 설명해 주세요.",
        arr: `
            1. var<br />
             - 중복 선언 가능<br />
             - 함수레벨 스코프<br />
            2. let<br />
             - 중복 선언 불가능<br />
             - 재할당 가능<br />
             - 블록레벨 스코프<br />
            3. const<br />
             - 중복 선언 불가능<br />
             - 재할당 불가능<br />
             - 블록레벨 스코프<br />
            <br />
            let과 const는 블록 스코프를 갖고 공통적으로 재선언이 되지 않습니다. 그러나 let은 재할당이 가능하고, const는 선언과 동시에 할당이 되기 때문에 재할당이 불가능합니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
]

export const frontend = [
    {
        id: 1,
        title: "브라우저 렌더링 과정을 설명해 주세요.",
        arr: `
            1. Parsing: HTML파일과 CSS파일의 파싱해 각각 트리를 만들어줍니다.<br />
            2. Style: 두 트리를 결합해서 렌더링 트리( Rendering Tree )를 만들어줍니다.<br />
            3. Layout: 렌더링 트리에서 각 노드의 위치와 크기를 계산합니다.<br />
            4. Paint: 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만들어줍니다.<br />
            5. Composite: 레이어를 합성하여 실제 화면에 나타내줍니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/324",
        link2: "https://d2.naver.com/helloworld/59361"
    },
    {
        id: 2,
        title: "로컬 스토리지, 세션 스토리지, 쿠키에 대해서 설명해 주세요.",
        arr: `
            1. 로컬스토리지 ( localStorage )<br />
             - 로컬스토리지는 브라우저 내에서 로컬로 데이터를 저장할 수 있는 저장소입니다. 로컬스토리지에 저장된 데이터는 사용자가 브라우저를 새로고침 하거나 브라우저를 닫은 후에도 그대로 유지됩니다.<br />
            <br />
            2. 세션스토리지 ( sessionStorage )<br />
             - 세션트로지는 로컬스토리지와 비슷하지만 사용자가 브라우저를 닫으면 저장된 데이터가 사라집니다. 일회성 로그인, 비회원 장바구니와 같은 임시 데이터를 저장하는데 사용될 수 있습니다.<br />
            <br />
            3. 쿠키 ( Cookie )
             - 쿠키는 클라이언트 로컬에 저장되는 키와 값이 있는 매우 작은 텍스트 파일입니다. 4kb의 크기 제한이 있으며, 일정 시간이 지나면 만료되도록 설정할 수 있고 만료 후에는 브라우저에서 사라집니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/432",
        link2: ""
    },
    {
        id: 3,
        title: "CSR, SSR의 차이점을 설명해 주세요.",
        arr: `
            1.CSR ( Client Side Rendering )<br />
             - 클라이언트측에서 HTML을 반환한 후에, 자바스크립트가 동작하면서 데이터만을 주고받아 클라이언트에서 렌더링을 진행합니다.<br />
            <br />
            2. SSR ( Server Side Rendering )<br />
             - 사용자가 웹 페이지에 접근할 때, 서버 각 페이지에 대해 요청하고 서버에서 HTML, Javascript 파일등을 모두 다운로드하여 화면에 렌더링을 진행합니다.<br />
            <br />
            <br />
            초기로딩 측면에서 SSR은 CSR에 비해 다운받는 파일이 많지 않기 때문에 속도가 빠른 반면, CSR은 모든 자바스크립트파일을 받아와야 하기 때문에 초기에 오래 걸립니다.<br />
            서버 부담측면에서 SSR은 서버와 잦은 응답을 하기 때문에 서버에 부담이 되고 UX측면이 떨어지는 반면, CSR은 데이터 요청이 있을때만 서버에 요처아기 때문에 서버에 부담이 적습니다.<br />
            SEO 측면에서 SSR은 HTML에 대한 정보가 처음에 포함되어 있기 때문에( SEO에 사용되는 meta tag들이 미리 정의되어 있습니다. ) 데이터를 수집할 수 있어 SEO에 유리한 반면, CSR은 맨 처음 HTML 파일이 비어있기 때문에 데이터 수집에 어려움이 있습니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/441",
        link2: ""
    },
    {
        id: 4,
        title: "React, Angular, Vue의 차이점을 설명해 주세요.",
        arr: `
            먼저 React, Angular, Vue의 공통점은 SPA기반의 프론트엔드 프레임워크/라이브러리라는 점입니다. 리액트는 단방향 바인딩으로 부모 컴포넌트에서 Props가 자식 컴포넌트로 전달되고, 뷰나 앵귤러는 양방향 바인딩이 가능하다는 차이가 있습니다.<br />
            러닝커브는 뷰가 가장 낮으며, 리액트는 .jsx문법을 사용하며, 개발 생태계가 가장 잘 활성화 되어 있으며, 큰 규모의 어플리케이션 개발에 유리합니다.<br />
            앵귤러와 뷰는 프레임워크이며, 앵귤러는 타입스크립트를 사용함으로써 코드의 가독성과 안정성이 좋지만 러닝커브가 높습니다.
        `,
        isOpen: false,
        link: "",
        link2: ""
    },
    {
        id: 5,
        title: "MVC, MVVM 패턴에 대해 설명해 주세요.",
        arr: `
            1. MVC ( Model-View-Controller )<br />
            MVC 패턴은 Model( 데이터 ), View( 화면 ), Controller( 컨트롤러 )로 구성된 디자인 패턴입니다.<br />
             - Model: 모델은 프론트엔드 애플리케이션의 데이터 및 로직을 나타내며, 애플리케이션의 상태를 관리하고 모든 비즈니스 로직을 처리합니다.<br />
             - View: 뷰는 데이터를 렌더링 하고 사용자에게 표시 및 상호작용 할 수 있는 인터페이스를 만드는 역할을 합니다.<br />
             - Controller: 컨트롤러는 모델과 뷰 사이의 중재자 역할을 합니다. 사용자의 입력을 처리하고 그에 따라 모델과 뷰를 업데이트합니다.<br />
            <br />
            2. MVVM ( Model-View-ViewModel )<br />
            MVVM 패턴은 Model, View, ViewModel로 구성되어 있으며 React, Angular, Vue와 같은 라이브러리나 프레임워크에서 일반적으로 사용되는 디자인 패턴입니다.<br />
             - Model: 모델은 MVC패턴과 마찬가지로 애플리케이션의 데이터와 로직을 나타냅니다.<br />
             - View: 뷰는 MVC패턴과 같이 데이터를 렌더링하고 사용자에게 표시하는 역할을 합니다.<br />
             - ViewModel: 뷰모델은 모델과 뷰 사이의 중재자 역할을 하며, 모델의 데이터를 뷰에 표시하기 쉬운 형식으로 변환하는 역할을 합니다. 또한 데이터에 대한 모든 업데이트를 처리하고 이를 모델에 다시 전달합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/443",
        link2: ""
    },
    {
        id: 6,
        title: "브라우저 주소창에 www.google.com을 입력하면 발생하는 일을 설명해 주세요.",
        arr: `
            1. 사용자가 웹브라우저 검색창에 www.google.com을 입력합니다.<br />
            2. 웹브라우저는 캐싱된 DNS 기록들을 통해 해당 도메인 주소와 대응하는 IP주소를 확인합니다.<br />
            3. 웹브라우저가 HTTP를 사용하여 DNS에게 입력된 도메인 주소를 요청합니다.<br />
            4. DNS가 웹브라우저에게 찾는 사이트의 IP주소를 응답합니다.<br />
            5. 웹브라우저가 웹 서버에게 IP주소를 이용하여 HTML문서를 요청합니다.<br />
            6. 웹 애플리케이션 서버( WAS )와 데이터베이스에서 우선 웹페이지 작업을 처리합니다.<br />
            7. 작업처리 결과를 웹서버로 전송합니다.<br />
            8. 웹 서버는 웹브라우저에게 HTML문서 결과를 응답합니다.<br />
            9. 웹브라우저는 화면에 웹페이지 내용을 출력합니다.
        `,
        isOpen: false,
        link: "https://shiro21.tistory.com/285",
        link2: ""
    },
]